##### 面向连接和无连接

* 面向连接服务就是在双方通信之前, 必须建立连接, 在通信过程中, 整个连接的情况一直是被实时地监控和管理. 通信结束后, 应该释放整个连接.
* 无连接服务是指两个实体在通信之前不需要先建立好连接, 需要通信时, 直接将信息发送到网络中, 让该信息的传递在网上尽力而为地往目的地传送.

##### TCP

TCP协议全称是传输控制协议是一种面向连接的、 可靠的、 基于字节流的传输层通信协议.

###### 三次握手

![img](./image/02.01.jpeg)

所谓的三次握手即TCP连接的建立. 这个连接必须是一方主动打开, 另一方被动打开的.

握手之前主动打开连接的客户端结束CLOSED阶段, 被动打开的服务器端也结束CLOSED阶段, 并进入LISTEN阶段. 随后开始"三次握手":

1. 首先客户端向服务器端发送一段TCP报文, 其中:
标记位为SYN, 表示"请求建立新连接"; 
序号为Seq=X(X一般为1); 
随后客户端进入SYN-SENT阶段.
2. 服务器端接收到来自客户端的TCP报文之后, 结束LISTEN阶段. 并返回一段TCP报文, 其中:
标志位为SYN和ACK, 表示"确认客户端的报文Seq序号有效, 服务器能正常接收客户端发送的数据, 并同意创建新连接"(即告诉客户端, 服务器收到了你的数据); 
序号为Seq=y; 
确认号为Ack=x+1, 表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值; 随后服务器端进入SYN-RCVD阶段.
3. 客户端接收到来自服务器端的确认收到数据的TCP报文之后, 明确了从客户端到服务器的数据传输是正常的, 结束SYN-SENT阶段. 并返回最后一段TCP报文. 其中:
标志位为ACK, 表示"确认收到服务器端同意连接的信号"(即告诉服务器, 我知道你收到我发的数据了); 
序号为Seq=x+1, 表示收到服务器端的确认号Ack, 并将其值作为自己的序号值; 
确认号为Ack=y+1, 表示收到服务器端序号Seq, 并将其值加1作为自己的确认号Ack的值; 
随后客户端进入ESTABLISHED阶段.
服务器收到来自客户端的"确认收到服务器数据"的TCP报文之后, 明确了从服务器到客户端的数据传输是正常的. 结束SYN-SENT阶段, 进入ESTABLISHED阶段.

在客户端与服务器端传输的 TCP 报文中, 双方的确认号Ack和序号 Seq 的值, 都是在彼此 Ack 和 Seq 值的基础上进行计算的, 这样做保证了 TCP 报文传输的连贯性. 一旦出现某一方发出的 TCP 报文丢失, 便无法继续"握手", 以此确保了"三次握手"的顺利完成.

此后客户端和服务器端进行正常的数据传输. 这就是"三次握手"的过程.

把客户端比作男孩, 服务器比作女孩. 用他们的交往来说明"三次握手"过程:

1. 男孩喜欢女孩, 于是写了一封信告诉女孩: 我爱你, 请和我交往吧!; 写完信之后, 男孩焦急地等待, 因为不知道信能否顺利传达给女孩.
2. 女孩收到男孩的情书后, 心花怒放, 原来我们是两情相悦呀! 于是给男孩写了一封回信: 我收到你的情书了, 也明白了你的心意, 其实, 我也喜欢你! 我愿意和你交往!; 
写完信之后, 女孩也焦急地等待, 因为不知道回信能否能顺利传达给男孩.
3. 男孩收到回信之后很开心, 因为发出的情书女孩收到了, 并且从回信中知道了女孩喜欢自己, 并且愿意和自己交往. 然后男孩又写了一封信告诉女孩: 你的心意和信我都收到了, 谢谢你, 还有我爱你!
女孩收到男孩的回信之后, 也很开心, 因为发出的情书男孩收到了. 由此男孩女孩双方都知道了彼此的心意, 之后就快乐地交流起来了~~

这就是通俗版的"三次握手", 期间一共往来了三封信也就是"三次握手", 以此确认两个方向上的数据传输通道是否正常.

###### 四次挥手

![img](./image/02.02.jpeg)

1. 首先客户端想要释放连接, 向服务器端发送一段TCP报文, 其中:
标记位为FIN, 表示"请求释放连接"; 
序号为Seq=U; 
随后客户端进入FIN-WAIT-1阶段, 即半关闭阶段. 并且停止在客户端到服务器端方向上发送数据, 但是客户端仍然能接收从服务器端传输过来的数据.
注意: 这里不发送的是正常连接时传输的数据(非确认报文), 而不是一切数据, 所以客户端仍然能发送ACK确认报文.

2. 服务器端接收到从客户端发出的TCP报文之后, 确认了客户端想要释放连接, 随后服务器端结束ESTABLISHED阶段, 进入CLOSE-WAIT阶段(半关闭状态)并返回一段TCP报文, 其中:
标记位为ACK, 表示"接收到客户端发送的释放连接的请求"; 
序号为Seq=V; 
确认号为Ack=U+1, 表示是在收到客户端报文的基础上, 将其序号Seq值加1作为本段报文确认号Ack的值; 
随后服务器端开始准备释放服务器端到客户端方向上的连接.
客户端收到从服务器端发出的TCP报文之后, 确认了服务器收到了客户端发出的释放连接请求, 随后客户端结束FIN-WAIT-1阶段, 进入FIN-WAIT-2阶段
前"两次挥手"既让服务器端知道了客户端想要释放连接, 也让客户端知道了服务器端了解了自己想要释放连接的请求. 于是, 可以确认关闭客户端到服务器端方向上的连接了

3. 服务器端自从发出ACK确认报文之后, 经过CLOSED-WAIT阶段, 做好了释放服务器端到客户端方向上的连接准备, 再次向客户端发出一段TCP报文, 其中:
标记位为FIN, ACK, 表示"已经准备好释放连接了". 注意: 这里的ACK并不是确认收到服务器端报文的确认报文.
序号为Seq=W; 
确认号为Ack=U+1; 表示是在收到客户端报文的基础上, 将其序号Seq值加1作为本段报文确认号Ack的值.
随后服务器端结束CLOSE-WAIT阶段, 进入LAST-ACK阶段. 并且停止在服务器端到客户端的方向上发送数据, 但是服务器端仍然能够接收从客户端传输过来的数据.
4. 客户端收到从服务器端发出的TCP报文, 确认了服务器端已做好释放连接的准备, 结束FIN-WAIT-2阶段, 进入TIME-WAIT阶段, 并向服务器端发送一段报文, 其中:
标记位为ACK, 表示"接收到服务器准备好释放连接的信号".
序号为Seq=U+1; 表示是在收到了服务器端报文的基础上, 将其确认号Ack值作为本段报文序号的值.
确认号为Ack=W+1; 表示是在收到了服务器端报文的基础上, 将其序号Seq值作为本段报文确认号的值.
随后客户端开始在TIME-WAIT阶段等待2MSL.

把客户端比作男孩, 服务器比作女孩. 通过他们的分手来说明"四次挥手"过程.

1. "第一次挥手": 日久见人心, 男孩发现女孩变成了自己讨厌的样子, 忍无可忍, 于是决定分手, 随即写了一封信告诉女孩.
2. "第二次挥手": 女孩收到信之后, 知道了男孩要和自己分手, 怒火中烧, 心中暗骂: 你算什么东西, 当初你可不是这个样子的! 于是立马给男孩写了一封回信: 分手就分手, 给我点时间, 我要把你的东西整理好, 全部还给你! 男孩收到女孩的第一封信之后, 明白了女孩知道自己要和她分手. 随后等待女孩把自己的东西收拾好.
3. "第三次挥手": 过了几天, 女孩把男孩送的东西都整理好了, 于是再次写信给男孩: 你的东西我整理好了, 快把它们拿走, 从此你我恩断义绝!
4. "第四次挥手": 男孩收到女孩第二封信之后, 知道了女孩收拾好东西了, 可以正式分手了, 于是再次写信告诉女孩: 我知道了, 这就去拿回来!
   
这里双方都有各自的坚持:
* 女孩自发出第二封信开始, 限定一天内收不到男孩回信, 就会再发一封信催促男孩来取东西!
* 男孩自发出第二封信开始, 限定两天内没有再次收到女孩的信就认为, 女孩收到了自己的第二封信; 若两天内再次收到女孩的来信, 就认为自己的第二封信女孩没收到, 需要再写一封信, 再等两天…..

倘若双方信都能正常收到, 最少只用四封信就能彻底分手! 这就是"四次挥手".

##### UDP

UDP协议全称是用户数据报协议, 在网络中它与TCP协议一样用于处理数据包, 是一种无连接的协议. 在OSI模型中, 在第四层——传输层, 处于IP协议的上一层. UDP有不提供数据包分组、 组装和不能对数据包进行排序的缺点, 也就是说, 当报文发送之后, 是无法得知其是否安全完整到达的.
