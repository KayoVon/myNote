## JS 的几种模块化方案

* 在无模块化的阶段, 直接用 `script标签` 引入, 其顶层作用域就是全局作用域, 声明变量会污染全局环境
* 使用模块, 每一个模块都有自身的作用域, 不会污染全局环境

js 中现在比较成熟的有四种模块加载方案.

### **AMD 方案**: 异步加载, 不能按需加载, 浏览器的方案

AMD 全称为 Asynchronous Module Definition, 即异步模块加载机制.

* AMD 是基于第三方库 **require.js** 的规范. 是一种异步加载方案, 允许指定回调函数
* 通过 **define** 函数定义模块; 通过 **require** 函数加载模块, 第一个参数表示所有依赖的第三方模块, 第二个参数表示本模块的内容.
    

```js
    // 定义模块：define([id], [dependencies], factory)
    <!--mod1.js-->
    define('mod1', [depend1, depend2, ...], function(depend1， depend2) {
        // 模块加载完了之后的定义操作
    })

    // 加载模块：require([dependencies], callback)
    require(['mod1', 'mod2'], function(mod1, mod2) {
        // 模块加载完了之后要执行的操作
    });
    // 模块加载顺序
    depend1、 depend2、 mod1、 mod2...执行代码
```

* **依赖前置** , 依赖的第三方模块必须在一开始就写好; 
* **提前执行** , 依赖的第三方模块先都加载完再去执行代码.
* 定义模块时回调函数里涉及的依赖模块必须提前加载完(即使可能没用到), **不能实现按需加载**.

  

```js
  define('mod3', ['mod1', 'mod2'], function(mod1, mod2) {
      mod1.doSomething...
          if (false) {
              mod2.doSomething... // mod2模块不一定能用到，但还是要提前加载
          }
  });
```

### **CMD 方案**: 异步加载, 按需加载

CMD 的全称为 Common Module Definition, 公共模块定义规范.

* CMD 是基于第三方库 **sea.js** 的规范. 是一种异步加载方案.
* 通过 **define** 定义模块, **require** 引入模块
* **依赖就近**, 依赖的第三方模块哪里用到就写在哪里
* **延迟执行**, 依赖的第三方模块需要的时候再加载、 执行
  

```js
  define('mod1', function(require, exports, module) {
      var a = require('./a')
      a.doSomethimg()...
          if (false) {
              var b = require('./b')
              b.doSomething()...
          }
  })
```

### **CommonJS 方案**: 同步加载模块, 服务器的方案

* 内部有一个 **module** 对象, 通过 **module.exports={ }** 导出模块对象, 可以通过 **exports. 属性=值** 为模块对象添加属性, 通过 **require** 来引入模块对象.
* 模块 **加载机制**: 和 CMD 一样, 需要用到第三方模块的时候才去require, require的时候才去加载模块
* 模块 **执行机制**: 模块第一次被加载的时候会先去执行模块, 后面再 require 的时候就不用重复执行了.
* CommonJS是一种 **同步加载** 模块的规范, 适用于 **服务器端**. 因为服务器端的第三方模块文件一般放在本地硬盘, 加载比较快; 但如果是在 **浏览器端**, 由于模块的加载是使用网络请求, 因此使用异步加载的方式更加合适.

CommonJs 会首先在代码的最顶部, 添加如下代码:

```JS
function(exports, require, module, __filename, __dirname) {}
```

实际上模块中的代码都是包装在一个函数中执行的, 并且在函数执行时, 同时传递了 5 个实参:

* `exports`: 该对象用来将变量或者函数暴露到外部.
* `require`: 函数, 用来引入外部的模块.
* `module`: 代码当前模块本身, `exports`实际上就是`module`的一个属性. 既可以使用`exports`导出, 也可以使用`module.exports`导出. 其中`exports`只能通过给`exports`属性赋值的方式来向外暴露内部变量. 而`module.exports`既可以通过给属性赋值的方式来赋值, 也可以直接赋值.

### ES6模块化方案

* 优点: 避免命名冲突, 避免引入时的层层依赖, 更好的分离, 可复用性、 可维护性好
* 导出方式1: 默认导出 `export default{}` , 只能有一个, 导出的是一个模块对象
  + 导入:`import 模块对象名 from 模块` , 模块对象名随意
* 导出方式2: 命名导出 `export {}` , 可以有很多个, 导出的是具体的变量或方法
  + 导入:`import {变量名1, 变量名2} from 模块`

* 模块 **加载机制**: 和 AMD 一样, 需要把使用的模块先全部加载完再执行代码
* 模块 **执行机制**: 遇到import不会去执行模块, 只生成一个动态的只读引用, 编译时发现后面需要用到这个模块, 再去模块里取值.**静态加载**

### AMD 和 CMD 的区别

* AMD 是 **依赖前置** , 不管是定义还是引入模块, 所依赖的第三方模块必须一开始就写好; CMD 是 **就近依赖** , 依赖的第三方模块可以就近引入
* AMD 是 **提前执行** , 所依赖的第三方模块一开始就要都加载好; CMD 是 **延迟执行** , 需要用到第三方模块的时候才require加载.
* AMD 是 RequireJS 在推广过程中对模块定义的规范化产出, CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出.

### CommonJS 和 AMD 的区别

* CommonJS规范对模块的加载是 **同步** 的, 加载完成才能执行后面代码; AMD对模块的加载是 **异步** 的, 允许指定回调函数
* **服务器** 编程, 模块文件一般在本地硬盘, 加载比较快, 所以适用于CommonJS这种同步加载的方案
* **浏览器** 环境要从服务端加载模块, 这时候必须用非同步的方式, 所以浏览器端一般用AMD规范

### ES6 模块与 CommonJS 的区别

* 动态加载和静态加载
  + **CommanJS**:**动态加载** 模块. 模块依赖关系的建立发生在代码==运行==阶段.
    - CommanJS **require** 的时候加载的是 **模块对象**，这个对象只有在模块运行完后才会生成。 所以在模块被执行前, 并没有确定明确的依赖关系, 模块的导入、 导出发生在代码的 **运行阶段**（运行时加载--跑起来才知道）.
  + **ES6 Module**:**静态加载**. 模块依赖关系的建立发生在代码==编译==阶段.
    - ES6 模块 **不是对象**，它的对外接口只是一种 **静态定义**，在代码静态编译阶段就会生成，所以它在 **编译阶段** 就可以分析出模块的依赖关系（编译时加载--没跑也一目了然）.

* 值拷贝和动态映射
  + **CommanJS**: CommanJS模块导出的是 **值的拷贝**, 一旦输出一个值, 模块内部的 **变化就影响不到** 这个值.
    - 比如调用模块中导出的方法对模块值进行修改，不会影响已经导出的值，因为模块第一次加载的时候值会被缓存，并且这个值 **可读可写**。如果方法改变的是引用类型变量，那么已导出的引用类型会改变。
  + **ES6 Module**: ES6模块导出的是 **值的引用**, 模块内部值的变化会动态映射到导出值. 因为js引擎对脚本静态分析的时候, 遇到import会生成一个 **只读引用** , 等需要这个变量了, 再去被加载的模块去取值.

* 循环依赖
  + 两者都不支持循环依赖, 但是 ES6 Module 的特性使其可以被改写(利用动态映射特性), 从而实现循环依赖.
  
* 相比 CommanJS 来说, ES6有如下优点.
    - 死代码检测和排除：引入的模块那些没用到，不用跑也知道（灰的）.
    - 模块变量类型检查.
    - 编译器优化.
